//***THIS VERSION IS BEFORE THE HAND AND CARD STRUCT REWORKS */


/*How will it work?
Upon run, ask user if they are ready to play.
-> y, start game
-> n, quit game

**Game play loop**
Start by dealing a card to the house. Notify the user about this card.
**Deal loop**
Next, deal a card to the user.
Check for a bust. **
-> if there is a bust, notify the user they lost this hand.
    -> Ask if they would like to play again.
    -> If yes start from the beginning
-> if there is no bust, prompt if they would like to hit or stay
    ->if stay, move to house loop.
    ->if hit, restart deal loop.
**House loop**
Deal cards to the house until they are above a certain value.
if the house busts, the user wins
->prompt user if they would like to play again
    ->If y, restart game loop
    ->If n, quit application.
END OF APPLICATION
*/

/* What architecture will we need?
Cards can be represented as a number, suit pair. Predefined tuples or struct?
The deck will be an array wrapped in a module.
-> needs shuffle
-> dealFrom
-> display
Hands can just be tuples or arrays?
-> display
-> clear
*/

//Make a file that will hold career wins, losses, and blackjacks

//REMEMBER: because of crazy rust things 49 == 1 for debug mode
    //50 == 2 for debug mode
use std::io;
use rand::{thread_rng, Rng};
///Type alias refering to u8 for uniformity through program
type Cardvalue = u8;

///Card struct that holds a cards value as well as its suit as a static string literal
#[derive(Debug,Clone)]
struct Card{
    value: Cardvalue,
    suit: &'static str,
}
///Hand struct that contains a vector of Card structs
#[derive(Debug,Clone)]
struct Hand{
    cards: Vec<Card>,
}
///Implementations for the Hand struct
impl Hand{
    ///Iterates through all cards in a Hand and returns the sum of the values.
    fn calculate_total(&self) -> Cardvalue{
        let mut sum:Cardvalue = 0;
        for x in self.cards.iter(){
            sum += x.value;
        }
        return sum;
    }
    ///Takes a Card and adds it to the Hand's current vector of Cards.
    fn add_card(&mut self, card: Card){
        self.cards.push(card);
    }
    ///Prints information about the cards held in the Hand card by card.
    fn print_hand(&self){
        for (x,card) in self.cards.iter().enumerate(){
            println!("Card {}, {} of {}",x,card.value, card.suit);
        }
    }
}

thread_local!(static DEBUG_MODE: Option<String> = std::env::args().skip(1).next(););
///Acts as a driver that runs the game loop function to create an endless loop
/// 
/// Loops while bool variable replay is true. Replay will be set to false in other areas
/// of the program to signal the user wanting to quit.
/// 
/// Once replay is set to false, the loop exits and a leaving message is displayed.
fn main() {
    //DEBUG_MODE.with(||{println!("{}",)})
    let mut replay = true;
    while replay {
        game_body(&mut replay);
    }
    println!("Thanks for playing!");
    
}
///Retrieves an argument passed in at the command line to dictate the debug mode the program should be run in
/// 
/// 0 (or no input) means no debug messages will be printed
/// 1 means debug messages will be printed.
fn get_debug_mode()->u8{
    DEBUG_MODE.with(|value|{
        if !(value.as_ref() == None){
            return value.as_ref().unwrap().as_str().as_bytes()[0] - 48
        }else{
            return 0;
        }
    })
}
/*
Take input should get input from the user
and ensure that the input is good based on the expected_answers Vector

An internal loop does not break until an acceptable input was given.
*/
///Retrieve input from the user after the program has started. This is called whenever input from the user is necessary.
/// 
/// Arguments:
/// * expected_answers: &Vec<char>. Vector of characters that take_input will accept as valid input.
/// * prompt: &str. Message to be displayed to the user each time input is attempted.
/// 
/// Returns:
/// * char. User's chosen option to be used by the calling function.
fn take_input(expected_answers: &Vec<char>,prompt:&str)->char{
    loop{
        //Declare new mutable string object for use in read_line
        let mut buffer = String::new();
        //Print the prompt message with expected inputs
        println!("{}, or (q) to quit.",prompt);
        //Assign user input to buffer string
        match io::stdin().read_line(&mut buffer){
            Ok(n) => n,
            Err(err) => panic!("{}", err),
        };
        //Trim whitespace and newlines from buffer
        buffer = buffer.trim().to_string();
        //extract the first character from user input
        if buffer.len() <=0{
            println!("Bad input recieved");
            continue;
        }
        let c: char = buffer.chars().collect::<Vec<char>>()[0];
        //Check user input against all expected inputs
        if c == 'q'{
            panic!("Thanks for playing!");
        }
        if expected_answers.contains(&c){
            //If input is good, return to calling function with user selection.
            return c;
        }else{
            //If input is bad, continue looping until good input.
            println!("Bad input recieved");
            continue;
        }//end of expected_answers if
    }//end of input loop
}//end of take_input

///Main gameplay loop that houses logic for the game.
/// 
/// Arguments:
/// * replay: &mut bool. Boolean value that reports wether or not the user would like to play again
/// once game hand is finished.
fn game_body(replay: &mut bool){
    //initialize variables and such
    println!("Welcome to blackjack! Press (q) at any time to quit");
    
    take_input(&vec!['r'], "Press (r) to begin!");
    
    //Game starts, dealer gets 1 card, then user gets to take their entire turn.
    //For now all hands will be vectors of u8, because a card will only be a integer value.
    //Suits will come later
    //let mut dealer_hand: Vec<Cardvalue> = Vec::new();
    //let mut player_hand: Vec<Cardvalue> = Vec::new();
    let mut dealer_hand: Hand = Hand{cards: Vec::<Card>::new()};
    let mut player_hand: Hand = Hand{cards: Vec::<Card>::new()};
    //Function call to deal_card that will return a random int between 1 and 13
    //dealer_hand.push(deal_card());
    deal_cards(1,&mut dealer_hand);
    println!("Dealing the dealers hand.");
    print_hand(&dealer_hand);
    deal_cards(2,&mut player_hand);
    println!("Dealing your hand.");
    print_hand(&player_hand);
    //Player control. Hit or stay
    loop{
        let answer: char = take_input(&vec!['h','s'], "Would you like to (h) hit or (s) stay?");
        if answer == 'h'{
            //hit
            player_hand.push(deal_card(true));
            //print_hand(&player_hand);
            print_both_hands(&player_hand,&dealer_hand);
            if calculate_hand(&player_hand) > 21 {
                println!("Bust!");
                *replay = play_again();
                return;
            }
        }else{
            //stay
            //Dealers turn. Implement "AI" for dealer turn.
            //For now just see who's total is bigger without being over.
            //Theres your winner.
            println!("Dealing card to the dealer.");
            dealer_hand.push(deal_card(true));
            if calculate_hand(&player_hand) > calculate_hand(&dealer_hand){
                println!("You win!");
            }else if calculate_hand(&player_hand) == calculate_hand(&dealer_hand) {
                println!("Tie game!");
            }else{
                println!("You lose!");
            }
            *replay = play_again();
            return;
        }
    }
}
///Asks user if they would like to play again and returns true or false.
/// 
/// Returns:
/// * Boolean indicating whether or not to play another hand.
fn play_again() -> bool{
    let answer = take_input(&vec!['y','n'],"Play again? (y) or (n)");
    if answer == 'y'{
        true
    }else{
        false
    }
}
///**OUTDATED AS OF HAND REFACTOR**
///Returns the sum of the card values contained in a given hand
/// 
/// Arguments:
/// hand: &Vec<Cardvalue>. The hand to be counted
/// 
/// Returns:
/// *Cardvalue (u8) that is the total value of the given hand.
fn calculate_hand(hand: &Vec<Cardvalue>) -> Cardvalue{
    return hand.iter().sum()
}
/*
    deal_cards: Populates <hand> vector with <amount> Cardvalues
*/
///Generates a set of random numbers used to deal cards to a given hand.
/// 
/// Arguments:
/// *amount: u8. Number of cards to generate and then deal.
/// *hand: &mut Vec<Cardvalue>. The hand to populate with the generated Cardvalues.
fn deal_cards(amount:u8, hand: &mut Vec<Cardvalue>){
    let mut random_numbers: Vec<Cardvalue> = Vec::new();
    for _x in 1..=amount {
        random_numbers.push(deal_card(false));
    }
    for x in random_numbers.iter(){
        hand.push(*x);
    }
}
/* 
    print_hand: Prints the entire hand, of a player.
    param -> hand: &Vec<u8>. Vector to iterate over.
    Enumerates over an iterator of that vector and prints the index and value of all the cards
*/
///Prints the contents of a given hand in the format "Card <#>, <value>". Totals the hand aswell and prints the total.
/// 
/// Arguments:
/// *hand: &Vec<CardValue>. The hand to print and total.
fn print_hand(hand: &Vec<Cardvalue>){
    for (x,card) in hand.iter().enumerate(){
        println!("Card {}, {}",x+1,card);
    }
    println!("Hand total: {}",calculate_hand(hand));
}
///Prints the contents of both hands given in a more readable and "game friendly" format.
/// 
/// Arguments:
/// * player_hand: &Vec<Cardvalue> Players hand
/// * dealer_hand: &Vec<Cardvalue> Dealers hand
fn print_both_hands(player_hand: &Vec<Cardvalue>,dealer_hand: &Vec<Cardvalue>){
    //let player_iter = player_hand.iter();
    //let dealer_iter = dealer_hand.iter();
    let mut larger_hand = Vec::<u8>::new();
    let mut other_hand = Vec::<u8>::new();
    let mut size:usize = 0;
    let mut hand_info:Vec<String> = Vec::new();
    //Populate hand_info with player_hand first, then dealer_hand.
    for x in player_hand.iter(){
        hand_info.push(format!("{} of {}",x, "Spades"));
    }
    //We got um bois
    for y in hand_info.iter_mut(){
        println!("{}",y);
    }
    /* if player_hand.len() >= dealer_hand.len(){
        size = player_hand.len();
        larger_hand = player_hand.clone();
        other_hand = dealer_hand.clone();
    }else{
        size = dealer_hand.len();
        larger_hand = dealer_hand.clone();
        other_hand = player_hand.clone();
    };
    for x in 0..size{
        //println!("Card {}, {:?} of {:?} \t\t Card {}, {:?} of {:?}",
                //x, player_hand.get(x).unwrap_or(""),"Spades",x,dealer_hand.get(x).unwrap_or(""),"Spades");
        
        if other_hand.get(x) != None{
                println!("Card {}, {:?} of {:?} \t\tCard {}, {:?} of {:?}",
                x, larger_hand.get(x).unwrap() + 1,"Spades",x,other_hand.get(x).unwrap() +1,"Spades");
        }else{
            println!("Card {}, {:?} of {:?} \t\t------------------------",
                x, larger_hand.get(x).unwrap() +1,"Spades");
        }
    } */
    //I could turn hand into a struct that has a method that will return
    //an element at that index if it exists or return "" if not.
}
/*
    deal_card: returns a random number of type Cardvalue
*/
///Returns a random number between 1 and 10 (formatted as a Cardvalue)
/// 
/// Arguments:
/// * print_message: bool. If true, prints a message for the user to see what value was generated.
fn deal_card(print_message:bool) -> Cardvalue{
    return get_random_num(print_message)
}
/*
    get_random_num: returns a random value of type Cardvalue
    Uses thread_rng() and .gen_range() to produce a random value.
*/
///Generates a random number between 1..10(Obsolete, will be changed soon) that will be used to make new cards.
/// 
/// Arguments:
/// * print_message: bool. If true, prints a message for the user to see what value was generated.
fn get_random_num(print_message:bool)->Cardvalue{
    let mut rng = thread_rng();
    // Exclusive range
    let n: Cardvalue = rng.gen_range(1..10);
    if get_debug_mode() == 1{
        println!("Number generated: {}",n);
    }
    if print_message {
        println!("Card dealt: {}", n);
    }
    n
}
